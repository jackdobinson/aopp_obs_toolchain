 
\subsection{Usage}
Interpolation is the process of ``filling in" values that are in-between data that we already have. There are various well documented methods \cite{InterpolationOverview} to perform this task.

For the implementation in the deconvolution tutorials, I've used \code{scipy}'s \code{interpolate.griddata} function for the actual interpolation. I've built an interface in \code{utilities.sp.interpolate_at_mask} that interpolates a \code{numpy} array at the \code{true} positions of a boolean \emph{bad pixel} array.

The prototype
\begin{lstlisting}
def interpolate_at_mask(data, mask, edges=None, **kwargs):
\end{lstlisting}
has three arguments:
\begin{description}
	\item{\code{data}} a \code{numpy} array holding the data to interpolate
	\item{\code{mask}} a \code{numpy} boolean array that is \code{true} in the places that should be interpolated
	\item{\code{edges}} an optional string describing how the edges should be treated, mostly used when an image has a ``frame'' of \code{NAN}s.
	\begin{description}
		\item{\code{None}} Don't worry about edges, ignore them
		\item{\code{"convolution"}} 
			\begin{itemize}
			\item Convolve the whole image with a square kernel that is 1/2 its shape (i.e., a $40 \times 30$ array is convolved with a square $20 \times 15$ to give a $78 \times 58$ array when you include partial overlaps). That way we should create a map that, in the regions outside the original \code{data}, has some relation to \code{data} and is somewhat continuous with the edges of \code{data} that are not NANs. 
			\item Embed the \code{data} we are not interpolating over into the convolved map so we now have no edges that are NANs and can't be interpolated over.
			\item Interpolate the embedded \code{data} array.
			\item Remove the `frame' of convolved data and just return the embedded \code{data}.
			\end{itemize}
	\end{description}
	\item{\code{kwargs}} other keyword arguments are forwarded to \code{scipy.interpolate.griddata}.
\end{description}