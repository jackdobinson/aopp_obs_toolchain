\hypertarget{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob}{}\doxysection{aopp\+\_\+deconv\+\_\+tool.\+algorithm.\+bad\+\_\+pixels.\+ssa\+\_\+sum\+\_\+prob Namespace Reference}
\label{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob}\index{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
np.\+ndarray \mbox{\hyperlink{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a0e0fe33e092827d3b6949a88597446c4}{pixel\+\_\+map}} (img, test, value, show\+\_\+plots=0, plot\+\_\+kw=\{\}, cutoff\+\_\+func=lambda \+\_\+test, \mbox{\hyperlink{classaopp__deconv__tool_1_1stats_1_1empirical_1_1EmpiricalDistribution}{Empirical\+Distribution}}(\+\_\+test.\+ravel()).ppf(\+\_\+value) \+\_\+value, bp\+\_\+mask\+\_\+func=lambda \+\_\+test, \+\_\+test $>$ \+\_\+cutoff \+\_\+cutoff)
\item 
def \mbox{\hyperlink{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a4a522bbf96785742e41bb09f604c26ae}{plot\+\_\+pixel\+\_\+map\+\_\+test}} (img, test, cutoff, mask, interp, plot\+\_\+kw=\{\})
\item 
def \mbox{\hyperlink{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a7b58f544ed0295af5dc8b81e398fd640}{ssa2d\+\_\+sum\+\_\+prob\+\_\+map}} (ssa, start=5, stop=None, value=0.\+99, Literal\mbox{[}\textquotesingle{}prob\+\_\+frac\+\_\+from\+\_\+median\textquotesingle{}\mbox{]}$\vert$Literal\mbox{[}\textquotesingle{}n\+\_\+std\+\_\+dev\+\_\+from\+\_\+median\textquotesingle{}\mbox{]} strategy=\textquotesingle{}n\+\_\+std\+\_\+dev\+\_\+from\+\_\+median\textquotesingle{}, show\+\_\+plots=0, list\mbox{[}Literal\mbox{[}\textquotesingle{}median\+\_\+prob\textquotesingle{}, \textquotesingle{}ppf\textquotesingle{}\mbox{]},\mbox{]} transform\+\_\+value\+\_\+as=\mbox{[}\textquotesingle{}ppf\textquotesingle{}\mbox{]}, weight\+\_\+by\+\_\+evals=False, smooth\+\_\+sigma=None)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a25be601f89deeeb773254f8540026a11}{\+\_\+lgr}} = \mbox{\hyperlink{namespaceaopp__deconv__tool_1_1cfg_1_1logs_a858779f4bf60872f01cc77b643fedc79}{aopp\+\_\+deconv\+\_\+tool.\+cfg.\+logs.\+get\+\_\+logger\+\_\+at\+\_\+level}}(\+\_\+\+\_\+name\+\_\+\+\_\+, \textquotesingle{}DEBUG\textquotesingle{})
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a0e0fe33e092827d3b6949a88597446c4}\label{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a0e0fe33e092827d3b6949a88597446c4}} 
\index{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}!pixel\_map@{pixel\_map}}
\index{pixel\_map@{pixel\_map}!aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}}
\doxysubsubsection{\texorpdfstring{pixel\_map()}{pixel\_map()}}
{\footnotesize\ttfamily  np.\+ndarray aopp\+\_\+deconv\+\_\+tool.\+algorithm.\+bad\+\_\+pixels.\+ssa\+\_\+sum\+\_\+prob.\+pixel\+\_\+map (\begin{DoxyParamCaption}\item[{}]{img,  }\item[{}]{test,  }\item[{}]{value,  }\item[{}]{show\+\_\+plots = {\ttfamily 0},  }\item[{}]{plot\+\_\+kw = {\ttfamily \{\}},  }\item[{}]{cutoff\+\_\+func = {\ttfamily lambda~\+\_\+test},  }\item[{\mbox{\hyperlink{classaopp__deconv__tool_1_1stats_1_1empirical_1_1EmpiricalDistribution}{Empirical\+Distribution}}(\+\_\+test.\+ravel()).ppf(\+\_\+value)}]{\+\_\+value,  }\item[{}]{bp\+\_\+mask\+\_\+func = {\ttfamily lambda~\+\_\+test},  }\item[{\+\_\+test $>$ \+\_\+cutoff  }]{\+\_\+cutoff }\end{DoxyParamCaption})}

\begin{DoxyVerb}    Finds a mask for an image based on values in 'test'.

    # ARGUMENTS #
        img : np.ndarray([:,:], type.T1)
            image to construct mask for (not actually used in calculation, but used in plotting)
        test : np.ndarray([:,:], type.T2)
            Array that cutoff will be applied to to find mask
        value : type.T3
            Value to calculate cutoff from using 'cutoff_func'
        show_plots : bool
            If True, will plot results of mapping.
        plot_kw : dict
            Dictionary to pass optional arguments to plots.
            {   'suptitle' : str
                    A string to display as the super-title of the plotted figure
            }
        cutoff_func : Callable[np.ndarray([:,:],type.T2), type.T3] -> type.T4
                = lambda _t, _v: ut.sp.construct_ppf_from(_t.ravel())(_v)
            A function that calculates the cutoff from 'value'. The cutoff is used
            to detemine the mask.
        bp_mask_func : Callable[np.ndarray([:,:],type.T2), type.T4] -> np.ndarray([:,:],bool)
                = lambda _t, _c: _t > _c
            A function that calculates the mask from the test and cutoff (cutoff is calculated
            from 'cutoff_func')
            
    # RETURNS #
        mask : np.ndarray([:,:],bool)
            A boolean array that can be used to mask 'img'\end{DoxyVerb}
 Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d3/dde/namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a0e0fe33e092827d3b6949a88597446c4_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d3/dde/namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a0e0fe33e092827d3b6949a88597446c4_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a4a522bbf96785742e41bb09f604c26ae}\label{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a4a522bbf96785742e41bb09f604c26ae}} 
\index{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}!plot\_pixel\_map\_test@{plot\_pixel\_map\_test}}
\index{plot\_pixel\_map\_test@{plot\_pixel\_map\_test}!aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}}
\doxysubsubsection{\texorpdfstring{plot\_pixel\_map\_test()}{plot\_pixel\_map\_test()}}
{\footnotesize\ttfamily def aopp\+\_\+deconv\+\_\+tool.\+algorithm.\+bad\+\_\+pixels.\+ssa\+\_\+sum\+\_\+prob.\+plot\+\_\+pixel\+\_\+map\+\_\+test (\begin{DoxyParamCaption}\item[{}]{img,  }\item[{}]{test,  }\item[{}]{cutoff,  }\item[{}]{mask,  }\item[{}]{interp,  }\item[{}]{plot\+\_\+kw = {\ttfamily \{\}} }\end{DoxyParamCaption})}

Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d3/dde/namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a4a522bbf96785742e41bb09f604c26ae_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a7b58f544ed0295af5dc8b81e398fd640}\label{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a7b58f544ed0295af5dc8b81e398fd640}} 
\index{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}!ssa2d\_sum\_prob\_map@{ssa2d\_sum\_prob\_map}}
\index{ssa2d\_sum\_prob\_map@{ssa2d\_sum\_prob\_map}!aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}}
\doxysubsubsection{\texorpdfstring{ssa2d\_sum\_prob\_map()}{ssa2d\_sum\_prob\_map()}}
{\footnotesize\ttfamily def aopp\+\_\+deconv\+\_\+tool.\+algorithm.\+bad\+\_\+pixels.\+ssa\+\_\+sum\+\_\+prob.\+ssa2d\+\_\+sum\+\_\+prob\+\_\+map (\begin{DoxyParamCaption}\item[{}]{ssa,  }\item[{}]{start = {\ttfamily 5},  }\item[{}]{stop = {\ttfamily None},  }\item[{}]{value = {\ttfamily 0.99},  }\item[{Literal\mbox{[}\textquotesingle{}prob\+\_\+frac\+\_\+from\+\_\+median\textquotesingle{}\mbox{]} $\vert$ Literal\mbox{[}\textquotesingle{}n\+\_\+std\+\_\+dev\+\_\+from\+\_\+median\textquotesingle{}\mbox{]} }]{strategy = {\ttfamily \textquotesingle{}n\+\_\+std\+\_\+dev\+\_\+from\+\_\+median\textquotesingle{}},  }\item[{}]{show\+\_\+plots = {\ttfamily 0},  }\item[{list\mbox{[}Literal\mbox{[}\textquotesingle{}median\+\_\+prob\textquotesingle{}, \textquotesingle{}ppf\textquotesingle{}\mbox{]},\mbox{]} }]{transform\+\_\+value\+\_\+as = {\ttfamily \mbox{[}\textquotesingle{}ppf\textquotesingle{}\mbox{]}},  }\item[{}]{weight\+\_\+by\+\_\+evals = {\ttfamily False},  }\item[{}]{smooth\+\_\+sigma = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}    Computes a bad pixel map from an SSA2D object. Concentrates on hot/cold pixels w.r.t background.
    
    Idea is that for a hot/cold pixel, the high frequency components of the SSA decomposition must 
    also be hot/cold. Therefore, the hot/cold pixels will consistently be at the *edges* of the
    pixel probability distribution for the higher frequency SSA components. As high frequency
    SSA components outnumber low frequency SSA components, we can just use all components as 
    long as we don't weight them by their eigenvalues (if we do, we should try and be selective
    to only the components where the scale of changes matches the scale of the hot/cold pixels).
    
    For each component of the SSA decomposition, a map is made of how far a given pixel deviates 
    from the median (range [-1,1]). The median differences for each component are combined together
    (by mean or weighted mean) to give a 'score' for each pixel. Bad pixels should have scores at the
    extreme ends of the [-1,1] range. A bad pixel map is chosen by taking the absolute value of the score,
    and selecting all pixels whose |score| is larger than a give value.

    # ARGUMENTS #
        ssa
            An SSA2D object
        start
            The first SSA component to include in the probability map
        stop
            The last SSA component to include in the probability map.
            If None, then will include as many SSA components as are present
        value
            A float that describes the quantile that denotes a 'bad pixel'
        strategy : 'prob_frac_from_median' | 'n_std_dev_from_median'
            How should we define an 'improbable' pixel?
                'prob_frac_from_median'
                    Fraction of probability space a pixel is away from 
                    the median value
                'n_std_dev_from_median'
                    Number of standard deviations a pixel is away from
                    the median value
        show_plots
            0 = do not show plots
            1 = show some plots
            2 = show interim plots
        transform_value_as
            List of literal strings that tells us how to tranform the "value"
            argument after which it is used as the cutoff for a bad pixel.
            If no options are given, "value" is used as the cutoff directly,
            i.e. if "value" is 0.99, then only pixels which have a median
            probability > 0.99 are classified as "bad pixels".

            Options are:
                "identity"
                    Use the value as-is, do not transform it
                "median_prob"
                    Transform "value" using the same function that we use to
                    change cumulative probabilities of pixels into probability
                    a pixel is a certain distance from the median.
                "ppf"
                    Transform "value" so that the cutoff is the percentage
                    point function of the pixel median probabilities. I.e.
                    if "value" is 0.9, then the cutoff will be set such that
                    10% of the pixels will be classified as "bad pixels"
        weight_by_evals
            If True, will weight each SSA component pixel probability by
            the component's eigenvalue when averaging into a combined score.
        perform_binary_opening : bool = True
            If True will perform binary opening on the result to remove single pixels
    # RETURNS #
        bp_mask
            A bad pixel mask. Pixels to reject are coded as True.\end{DoxyVerb}
 Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d3/dde/namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a7b58f544ed0295af5dc8b81e398fd640_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d3/dde/namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a7b58f544ed0295af5dc8b81e398fd640_icgraph}
\end{center}
\end{figure}


\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a25be601f89deeeb773254f8540026a11}\label{namespaceaopp__deconv__tool_1_1algorithm_1_1bad__pixels_1_1ssa__sum__prob_a25be601f89deeeb773254f8540026a11}} 
\index{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}!\_lgr@{\_lgr}}
\index{\_lgr@{\_lgr}!aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob@{aopp\_deconv\_tool.algorithm.bad\_pixels.ssa\_sum\_prob}}
\doxysubsubsection{\texorpdfstring{\_lgr}{\_lgr}}
{\footnotesize\ttfamily aopp\+\_\+deconv\+\_\+tool.\+algorithm.\+bad\+\_\+pixels.\+ssa\+\_\+sum\+\_\+prob.\+\_\+lgr = \mbox{\hyperlink{namespaceaopp__deconv__tool_1_1cfg_1_1logs_a858779f4bf60872f01cc77b643fedc79}{aopp\+\_\+deconv\+\_\+tool.\+cfg.\+logs.\+get\+\_\+logger\+\_\+at\+\_\+level}}(\+\_\+\+\_\+name\+\_\+\+\_\+, \textquotesingle{}DEBUG\textquotesingle{})\hspace{0.3cm}{\ttfamily [private]}}

