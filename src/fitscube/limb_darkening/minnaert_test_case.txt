#!/usr/bin/python3
"""
Contains routines for calculating Minnaert limb darkeing coefficients.

Minnaert limb darkening equation:

			 k  k-1
 I     /I\  u  u
--- = |---|  0                                                              (1)
 F     \F/
		 0

Where
	u = cos(zenith)
	u_0 = cos(solar zenith)
	k, (I/F)_0 are fixed parameters
	I/F is the flux at the zenith angle we are interested in

In our case, the solar zenith angle and the zenith angle are approximately the 
same as the earth and sun are very close when seen from Neptune

Taking the logarithm of (1) gives:

	ln[u(I/F)] = ln[(I/F)_0] + k ln[u_0 u]                                  (2)

-------------------------------------------------------------------------------
"""

import sys, os
import numpy as np
import scipy as sp
import scipy.optimize
import matplotlib.pyplot as plt

def get_coefficients_v_wavelength(u_0, u, IperF):
	"""
	Runs "get_coefficients()" for each wavelength and combines the output into a nice format

	# ARGUMENTS #
		u_0 [n]
			<float, array> cos(solar zenith)
		u [n]
			<float, array> cos(zenith)
		IperF [n]
			<float, array> Radiance (or flux, some brightness measure)

	# RETURNS #
		IperF0s
			<array, float> The values of IperF0 for each wavelength
		ks
			<array, float> The values of k for each wavelength
		log_IperF0s_var
			<array, float> The variance on the IperF0s values
		ks_var
			<array, float> The variance on the ks values
		n_valid_idxs
			<array, float> The number of datapoints used when performing the 
			minnaert fit 
		
	"""
	# get the number of wavelengths (assume wavelengths are 0th axis)
	wavshape = IperF.shape[0]
	
	# create numpy arrays to hold return data (faster than lists)
	IperF0s = np.full(wavshape, fill_value = np.nan)
	ks = np.full(wavshape, fill_value = np.nan)
	log_IperF0s_var = np.full(wavshape, fill_value=np.nan)
	ks_var = np.full(wavshape, fill_value=np.nan)
	n_valid_idxs = np.full(wavshape, fill_value=0)
	
	# loop over the wavelength axis (assume 0th) and get a minnaert fit
	# we only need some of the output so just grab the important parts.
	for i in range(wavshape):
		result = get_coefficients(u_0[i,:], u[i,:], IperF[i,:])
		IperF0s[i] = result[0]
		ks[i] = result[1]
		log_IperF0s_var[i] = result[8][0,0]
		ks_var[i] = result[8][1,1]
		n_valid_idxs[i] = np.nansum(result[7])
	
	return(IperF0s, ks, log_IperF0s_var, ks_var, n_valid_idxs)

def get_coefficients(u_0, u, IperF):
	"""
	Uses (2) to find k and (I/F)_0 for a set of u_0, u, (I/F) values

	re-write as a matrix equation of the form y=Ax, for each i^th triple of
	u_0, u, IperF we have:
		y = {... log[u(I/F)]_i ...}
		x = {log[(I/F)_0], k}
		A = {... 1_i ..., ... log[u_0 u]_i ...}
	We want to find the x that best predicts y.

	# ARGUMENTS #
		u_0 [n]
			<float, array> cos(solar zenith)
		u [n]
			<float, array> cos(zenith)
		IperF [n]
			<float, array> Radiance (or flux, some brightness measure)

	# RETURNS #
		IperF0
			<float> The minnaert parameter that tells you the brightness at zenith=0
		k
			<float> The minnaert parameter that determines limb brightening vs limb 
			darkening. Should be between 0 and 1 (0.5 is no brightening or darkening).
		residual [m]
			<float, array> residual = y - Ax for the found values of x
		rank
			<int> Rank of matrix A
		s 
			<int, array> Singular values of A
		log_u0u [n]
			<float, array> The values of log[u_0 u] in (2)
		log_uIperF [n]
			<float, array> The values of log[u(I/F)] in (2)
		valid_idxs [m]
			<bool, array> The indices of log_uIperF that are not NAN or INF 
			(as IperF could be less than zero due to background subtraction)
		cov_mat [2,2]
			<float, array> The covariance matrix for IperF0 and k
	
	# EXAMPLE #
		IperF0, k, residual, rank, s, log_u0u, log_uIperF, valid_idxs, cov_mat = get_coefficients(u0, u, IperF)
	"""
	
	# assume we have numpy arrays for all inputs
	# masked arrays don't play nice with scipy routines sometimes
	if type(IperF) == np.ma.MaskedArray:
		IperF = IperF.filled(fill_value=np.nan)

	# get inputs into the form of (2)
	log_u0u = np.log(u_0*u)
	log_uIperF = np.log(u*IperF)
	
	# sometimes will have -ve I/F values (noise and backgrounding) so find the valid indexes
	valid_idxs = (~np.isnan(log_uIperF)) & (~np.isinf(log_uIperF))
	
	# only operate on the valid indexes to avoid wierdness
	log_u0u_valid = log_u0u[valid_idxs]
	log_uIperF_valid = log_uIperF[valid_idxs]
	
	if np.unique(log_u0u_valid).size < 3:
		# then we can't get meaningful results so just return junk
		return(np.nan, np.nan, np.array([]), np.nan, np.nan, log_u0u, log_uIperF, np.array([]), np.array([[np.nan,np.nan],[np.nan,np.nan]]))
	
	
	# find matrix A, A = {... 1_i ..., ... log[u_0 u]_i ...}
	A = np.vstack([np.ones_like(log_u0u_valid), log_u0u_valid]).T
	
	if A.shape == (0,2):
		# then we didn't have any valid indexes, so the whole thing is NANs or INFs so just return junk
		return(np.nan, np.nan, np.nan, np.nan, np.nan, log_u0u, log_uIperF, [], np.full((2,2), fill_value=np.nan))
	
	# perform least squares fit to determine vector x
	# numpy version cannot constrain to bounds, so use scipy version.
	
	#x, residual, rank, s = np.linalg.lstsq(A, log_uIperF_valid, rcond=None)
	
	# bounds in form (IperF0 min, k min), (IperF0 max, k max)
	bounds = ((-np.inf,0),(np.inf,1))
	result = sp.optimize.lsq_linear(A, log_uIperF_valid, bounds=bounds)
	x = result.x
	residual = result.fun
	rank = np.nan
	s = np.nan
	
	# get the residuals of the fit
	fit_residuals = np.matmul(A, x) - log_uIperF_valid

	# == THOUGHTS ON COVARIANCE STUFF ==
	# note that cov_mat is the covariance of log(IperF0) and k, so need to take this into account
	# Assuming that the errors on log(IperF0) are distributed normally, then the errors on IperF0 are
	# distributed according to a log-normal distribution. So the variance of those errors is
	# sigma_IperF0 = np.exp(cov_mat[0,0] - 1)*np.exp(cov_mat[0,0])
	# see https://en.wikipedia.org/wiki/Log-normal_distribution
	# and assume that the mean of the errors on log(IperF0) is zero
	# BUT I DONT THINK THAT log(IperF0) is normally distributed, but IperF0 is,
	# Therefore may have to work out the errors by brute force, something like (exp(x+sqrt(var(x))) - exp(x-sqrt(var(x))))^2
	
	# == GETTING VARIANCE OF (I/F)0 FROM log[(I/F)0] ==
	# The error propagation that will give me the variance of IperF0 starting 
	# from log(IperF0) is confusing. Instead I can brute-force the problem
	# by calculating
	# IperF0s_var = (np.exp(np.log(IperF0s)+np.sqrt(log_IperF0s_var)) 
	#               - np.exp(np.log(IperF0s)-np.sqrt(log_IperF0s_var)))**2	
	
	AtA = np.matmul(A.transpose(), A)
	mat_inverted = False
	while not mat_inverted:
		try:
			AtA_inv = np.linalg.inv(AtA)
		except np.linalg.LinAlgError:
			# if we can't invert the matrix, make a small alteration until it's non-singular
			AtA += np.random.rand(2,2)*1E-10
			continue
		mat_inverted=True
		
	cov_mat = np.var(fit_residuals)*AtA_inv # see https://www.stat.purdue.edu/~boli/stat512/lectures/topic3.pdf

	return(np.exp(x[0]), x[1], residual, rank, s, log_u0u, log_uIperF, valid_idxs, cov_mat)
	
if __name__=='__main__':
	# parameters for test case
	n_points = 30
	n_fit_points = 50
	fractional_standard_deviation = 0.5
	
	# create some dummy data
	u0 = np.cos((np.pi/180)*np.linspace(0, 85, n_points))
	u = np.cos((np.pi/180)*np.linspace(0, 85, n_points))
	k_real = 0.7
	IperF0_real = 1E-6
	
	IperF = IperF0_real*(u0**k_real)*(u**(k_real-1))
	
	# Corrupt perfect data with some noise
	IperF += np.random.normal(0, fractional_standard_deviation*IperF0_real, u.shape)
	
	# Find the minnaert coefficients for the dummy data
	IperF0, k, residual, rank, s, log_u0u, log_uIperF, valid_idxs, cov_mat = get_coefficients(u0, u, IperF)
	
	# extract variances from covariance matrix
	log_IperF0_var = cov_mat[0,0]
	k_var = cov_mat[1,1]
	
	# get a set of points that span the log_u0u range
	log_u0u_grid = np.linspace(np.nanmin(log_u0u), np.nanmax(log_u0u), n_fit_points)
	
	# Calculate the line of best fit
	log_uIperF_fit = np.log(IperF0) + k*log_u0u_grid
	
	# calculate all possible combinations of the line of best fit +/- 1 standard 
	# deviation of the k and IperF0 coefficients
	worst_log_uIperF_fits = np.zeros((n_fit_points, 4))
	k_lims = (k + np.sqrt(k_var), k - np.sqrt(k_var))
	log_IperF0_lims = (np.log(IperF0) + np.sqrt(log_IperF0_var), np.log(IperF0) - np.sqrt(log_IperF0_var))
	_i = 0
	for _k in k_lims:
		for _l in log_IperF0_lims:
			worst_log_uIperF_fits[:,_i] = _l + _k*log_u0u_grid
			_i += 1
	
	# get the minimum and maximum 'worst fit' lines
	wf_min = np.nanmin(worst_log_uIperF_fits, axis=-1)
	wf_max = np.nanmax(worst_log_uIperF_fits, axis=-1)
	
	# create a plot
	nr, nc, s = (1,1, 6)
	f0 = plt.figure(figsize=(nc*s, nr*s))
	a0 = f0.subplots(nr,nc, squeeze=False)
	
	# fill plot with data
	a0[0,0].plot(log_u0u, log_uIperF, '.')
	a0[0,0].plot(log_u0u_grid, log_uIperF_fit, '-', color='tab:pink', label='Minnaert fitted line')
	a0[0,0].fill_between(log_u0u_grid, wf_min, wf_max, color='tab:pink', alpha=0.5, label='Minnaert fitted line error region')
	
	# annotate plot
	f0.suptitle('Minnaert test case', fontsize=6)
	a0[0,0].set_title(f'Minnaert limb darkening at wav TEST um\nlat TEST to TEST IperF0 {IperF0:05.2E} k {k:03.2f}')
	a0[0,0].set_xlabel('log[u0 u]')
	a0[0,0].set_ylabel('log[u (I/F)]')
	a0[0,0].legend()
	
	# show plot
	plt.show()
	
	
