#!/usr/bin/env python3

"""
Uses text files that are generated by 'minnaert2txt.py' and combines them into
a single "observation". Will overwrite files that already exist in the destination directory
"""

import sys, os
import glob
import numpy as np
import fitscube.limb_darkening.minnaert
import matplotlib.pyplot as plt
import matplotlib as mpl
import utils as ut
import plotutils

# loop over lat files and combine them together
# this is pretty inefficient because we have to load/reload stuff into memory every iteration
# however the logic is much simpler this way

def combine_minnaert_inputs(m_input_lat_files, combined_dir, overwrite=False):
	n_input_lat_files = len(m_input_lat_files)
	combined_m_input_lat_files = []
	
	lat_range_seen_list = []
	
	for i, m_input_lat_file in enumerate(m_input_lat_files):
		
		lat_min = float(m_input_lat_file.split('_')[-3])
		lat_max = float(m_input_lat_file.split('_')[-1].rsplit('.',1)[0])
		
		"""
		# DEBUGGING
		if lat_min != 45 and lat_max!=55:
			#print('DEBUGGING: Out of latitude range')
			continue
		"""
		
		print(f'INFO: Operating on file {m_input_lat_file} {i}/{n_input_lat_files}')
		#print(lat_min, lat_max)
		
		combined_m_input_lat_file = os.path.join(combined_dir, f'combined_minnaert_inputs_lat_{lat_min:+07.2f}_to_{lat_max:+07.2f}.npz')
		if os.path.exists(combined_m_input_lat_file) and (not overwrite) and ((lat_min, lat_max) not in lat_range_seen_list):
			combined_m_input_lat_files.append(combined_m_input_lat_file)
			print('INFO: File already existis, skipping')
			continue
		
		dl = np.load(m_input_lat_file)
		wavs, u, u0, IperF = (dl['wavs'], dl['u'], dl['u0'], dl['IperF'])
		#np.savez(m_input_lat_file, wavs=wavs, u=u, u0=u0, IperF=IperF)
	
		#print(IperF[IperF==0])
		#print(IperF.shape)
	
		# have to reload the file each time as we may not be dealing with the same latitude limits on each loop iteration
		if os.path.exists(combined_m_input_lat_file) and ((lat_min, lat_max) in lat_range_seen_list):
			# if the file exists, and we have already seen a file with this range before, then we should append to it
			cdl = np.load(combined_m_input_lat_file)
			c_wavs, c_u, c_u0, c_IperF = (cdl['wavs'], cdl['u'], cdl['u0'], cdl['IperF'])
		else:
			# otherwise we should create new data to put into the file
			c_wavs = wavs # wavelengths should be the same accross files
			c_IperF = np.zeros(list(IperF.shape[:-1])+[0])
			c_u = np.zeros(list(u.shape[:-1])+[0])
			c_u0 = np.zeros(list(u0.shape[:-1])+[0])
		
		#print(c_IperF.shape)
		
		# wavs should stay the same
		# concatenate the new data with the old data
		c_IperF = np.concatenate((c_IperF, IperF), axis=-1)
		c_u = np.concatenate((c_u, u), axis=-1)
		c_u0 = np.concatenate((c_u0, u0), axis=-1)
		
		# save combined data to combined data file
		os.makedirs(os.path.dirname(combined_m_input_lat_file), exist_ok=True) # ensure we have a folder to put our file in
		np.savez(combined_m_input_lat_file, wavs=c_wavs, u=c_u, u0=c_u0, IperF=c_IperF)
		if (lat_min, lat_max) not in lat_range_seen_list:
			# once we have created a file with this latitude range, record that we've done so
			lat_range_seen_list.append((lat_min,lat_max))
		combined_m_input_lat_files.append(combined_m_input_lat_file)
		print(f'INFO: combined data saved to {combined_m_input_lat_file}')
	return(combined_m_input_lat_files)


# calculate minnaert coefficients for the combined inputs
def combined_minnaert_coefficients(combined_minnaert_input_files, overwrite=False):
	n_combined_minnaert_input_files = len(combined_minnaert_input_files)
	cmcfs = []
	for i, cmif in enumerate(combined_minnaert_input_files):
		# DEBUGGING
		#if i!=10:
		#	continue
		
		print(f'INFO: calculating minnaert coefficients for file {cmif} {i}/{n_combined_minnaert_input_files}')
		cmcf = cmif.replace('_inputs_', '_coefficients_') # combined minnaert coefficients file
		if os.path.exists(cmcf) and (not overwrite):
			print('INFO: File already exists, skipping')
			cmcfs.append(cmcf)
			continue
		
		dl = np.load(cmif)
		
		wavs, u, u0, IperF = (dl['wavs'], dl['u'], dl['u0'], dl['IperF'])
		#if IperF.size < 3:
		#	print('INFO: Less than three points in this file, cannot get a meaningful fit, skipping...')
		
		IperF0s, ks, log_IperF0s_var, ks_var, n_valid_idxs = fitscube.limb_darkening.minnaert.get_coefficients_v_wavelength(u0, u, IperF)	
		IperF0s_var = (np.exp(np.log(IperF0s)+np.sqrt(log_IperF0s_var)) - np.exp(np.log(IperF0s)-np.sqrt(log_IperF0s_var)))**2
		
		if any(np.isinf(IperF0s_var)):
			print(f'ERROR: Infinity detected in variance of IperF0s when operating on file {i}, this usually means there is a problem')
			inf_idx = np.isinf(IperF0s_var)
			num_idx = ~np.isnan(IperF[inf_idx])
			print('log_IperF0s_var.shape', log_IperF0s_var.shape)
			print('u0[inf,not_nan]', u0[inf_idx][num_idx])
			print('IperF[inf,not_nan]', IperF[inf_idx][num_idx])
			print('IperF0s[inf]', IperF0s[inf_idx])
			print('IperF0s_var[inf]', IperF0s_var[inf_idx])
			print('log_IperF0s_var[inf]', log_IperF0s_var[inf_idx])
		
	
		np.savez(cmcf, wavs=wavs, IperF0s=IperF0s, ks=ks, log_IperF0s_var=log_IperF0s_var, ks_var=ks_var, IperF0s_var=IperF0s_var, n_points=np.ones_like(wavs)*IperF.shape[1], n_used_points=n_valid_idxs)
		cmcfs.append(cmcf)
	return(cmcfs)

########################### PLOT CREATION ROUTINES ###########################

# create plots
def plot_k_IperF0_wav_per_lat(combined_minnaert_coefficient_files, plot_dir, lat_grid=np.linspace(-90,90,180), wav_plot_lims=(1.455, 2.455)):
	n_cmcf = len(combined_minnaert_coefficient_files)
	
	wav_v_lat_v_IperF0 = None
	wav_v_lat_v_k = None
	wav_v_lat_coverage = None
	wav_v_lat_v_IperF0_std = None
	wav_v_lat_v_k_std = None
	wavelength_plot_lim_range = wav_plot_lims  # wavelength range to set the plot limits with
	
	for i, cmcf in enumerate(combined_minnaert_coefficient_files):
		print(f'INFO: creating plots of {cmcf} {i}/{n_cmcf}')
		
		lat_min = float(cmcf.split('_')[-3])
		lat_max = float(cmcf.split('_')[-1].rsplit('.',1)[0])
		print(lat_min, lat_max)
		
		
		dl = np.load(cmcf)
		wavs, IperF0s, ks, log_IperF0s_var, ks_var, IperF0s_var, n_points, n_used_points = (dl['wavs'], dl['IperF0s'], dl['ks'], 
																	dl['log_IperF0s_var'], dl['ks_var'], dl['IperF0s_var'],
																	dl['n_points'], dl['n_used_points'])
		shape = (lat_grid.size, wavs.size)
		if wav_v_lat_coverage is None:
			wav_v_lat_coverage = np.zeros(shape)
		if wav_v_lat_v_IperF0 is None:
			wav_v_lat_v_IperF0 = np.zeros(shape)
		if wav_v_lat_v_k is None:
			wav_v_lat_v_k = np.zeros(shape)
		if wav_v_lat_v_IperF0_std is None:
			wav_v_lat_v_IperF0_std = np.zeros(shape)
		if wav_v_lat_v_k_std is None:
			wav_v_lat_v_k_std = np.zeros(shape)
								
		lat_idx = np.nonzero((lat_min < lat_grid) & (lat_grid < lat_max))
		wav_v_lat_v_IperF0[lat_idx,:] += IperF0s[None,:]
		wav_v_lat_v_k[lat_idx,:] += ks[None,:]
		wav_v_lat_coverage[lat_idx,:] += 1
		wav_v_lat_v_IperF0_std[lat_idx,:] += np.sqrt(IperF0s_var)[None,:]
		wav_v_lat_v_k_std[lat_idx,:] += np.sqrt(ks_var)[None,:]
		
		wr = (wavelength_plot_lim_range[0]<wavs) & (wavs<wavelength_plot_lim_range[1])
		nr,nc = (2,2)
		f1 = plt.figure(figsize=(nc*5,nr*5))
		a1 = f1.subplots(nr,nc,squeeze=False)
		
		a1[0,0].plot(wavs, IperF0s)
		a1[0,0].fill_between(wavs, IperF0s+np.sqrt(IperF0s_var), IperF0s-np.sqrt(IperF0s_var), color='tab:orange', alpha=0.5)
		a1[0,0].set_xlabel('Wavelength (um)')
		a1[0,0].set_ylabel('IperF0')
		a1[0,0].set_ylim((np.nanmin(IperF0s[wr]),np.nanmax(IperF0s[wr])))
		a1[0,0].set_title('Value (line) Error (region)')
		
		a1[0,1].plot(wavs, ks)
		a1[0,1].fill_between(wavs, ks+np.sqrt(ks_var), ks-np.sqrt(ks_var), color='tab:orange', alpha=0.5)
		a1[0,1].set_xlabel('Wavelength (um)')
		a1[0,1].set_ylabel('k')
		a1[0,1].set_ylim((0,1))
		a1[0,1].set_title('Value (line) Error (region)')
		
		IperF0s_std = np.sqrt(IperF0s_var)
		ks_std = np.sqrt(ks_var)
		#print(IperF0s_var)
		#print(IperF0s_std)
		a1[1,0].plot(wavs, IperF0s_std, color='tab:orange')
		a1100 = a1[1,0].twinx()
		a1100.plot(wavs, ks_std, color='tab:green')
		a1100.set_ylabel('k_std (green)')
		a1[1,0].set_xlabel('Wavelength (um)')
		a1[1,0].set_ylabel('IperF0_std (orange)')
		a1[1,0].set_ylim((np.nanmin(IperF0s_std[wr]),np.nanmax(IperF0s_std[wr])))
	
		
		a1[1,1].plot(wavs, n_points, label='n_points')
		a1[1,1].plot(wavs, n_used_points, label='n_used_points')
		a1[1,1].set_xlabel('Wavelength (um)')
		a1[1,1].set_ylabel('Number of points input to minnaert curve fit')
		#a1[1,1].set_ylim((np.nanmin(ks_std[wr]),np.nanmax(ks_std[wr])))
		a1[1,1].legend()
		
		f1.suptitle(f'minnaert coefficients from lat {lat_min:+07.2f} to {lat_max:+07.2f}')
	
		f1.savefig(os.path.join(plot_dir, f'combined_lat_{lat_min:+07.2f}_to_{lat_max:+07.2f}_minnaert_coefficients.png'),
					bbox_inches='tight')
		plt.close(f1)
	
	covered = wav_v_lat_coverage != 0
	wav_v_lat_v_IperF0[covered] /= wav_v_lat_coverage[covered]
	wav_v_lat_v_k[covered] /= wav_v_lat_coverage[covered]
	wav_v_lat_v_IperF0_std[covered] /= wav_v_lat_coverage[covered]
	wav_v_lat_v_k_std[covered] /= wav_v_lat_coverage[covered]
	
	wav_v_lat_v_IperF0[~covered] = np.nan
	wav_v_lat_v_k[~covered] = np.nan
	wav_v_lat_v_IperF0_std[~covered] = np.nan
	wav_v_lat_v_k_std[~covered] = np.nan
	
	return(wav_v_lat_v_IperF0, wav_v_lat_v_k, wav_v_lat_v_IperF0_std, wav_v_lat_v_k_std)

# create wav v lat plot
def plot_k_IperF0_wav_lat(combined_m_coefficient_lat_files, plot_dir, 
							lat_grid=np.linspace(-90,90,180), wav_plot_lims=(1.455, 2.455)):
	extent = (wav_plot_lims[0], wav_plot_lims[-1], lat_grid[0], lat_grid[-1])
	
	cmap = mpl.cm.viridis
	cmap.set_over('red')
	cmap.set_under('cyan')
	
	wav_v_lat_v_IperF0, wav_v_lat_v_k, wav_v_lat_v_IperF0_std, wav_v_lat_v_k_std = minnaert_coefficients_to_lat_wav_format(
																											combined_m_coefficient_lat_files, 
																											lat_grid=lat_grid, 
																											wav_plot_lims=wav_plot_lims)
	
	nr,nc,s=(2,3,6)
	f2 = plt.figure(figsize=(s*nc,s*nr))
	a2 = f2.subplots(nr,nc,squeeze=False).T
	
	norm = mpl.colors.SymLogNorm(1E-3*np.nanmax(wav_v_lat_v_IperF0), linscale=1, vmin=0, vmax=np.nanmax(wav_v_lat_v_IperF0))
	
	im200 = a2[0,0].imshow(wav_v_lat_v_IperF0, origin='lower', extent=extent, aspect='auto', norm=norm, cmap=cmap)
	a2[0,0].set_title('Fitted IperF0')
	a2[0,0].set_xlabel('Wavelength (um)')
	a2[0,0].set_ylabel('Latitude (deg)')
	
	im201 = a2[0,1].imshow(wav_v_lat_v_k, origin='lower', extent=extent, aspect='auto', vmin=0, vmax=1, cmap=cmap)
	a2[0,1].set_title('Fitted k')
	a2[0,1].set_xlabel('Wavelength (um)')
	a2[0,1].set_ylabel('Latitude (deg)')
	
	im210 = a2[1,0].imshow(wav_v_lat_v_IperF0_std, origin='lower', extent=extent, aspect='auto', norm=norm, cmap=cmap)
	a2[1,0].set_title('Standard deviation of fitted IperF0')
	a2[1,0].set_xlabel('Wavelength (um)')
	a2[1,0].set_ylabel('Latitude (deg)')
	
	im211 = a2[1,1].imshow(wav_v_lat_v_k_std, origin='lower', extent=extent, aspect='auto', vmin=0, vmax=1, cmap=cmap)
	a2[1,1].set_title('Standard deviation of fitted k')
	a2[1,1].set_xlabel('Wavelength (um)')
	a2[1,1].set_ylabel('Latitude (deg)')
	
	norm2 = mpl.colors.SymLogNorm(1E-3*np.nanmax(wav_v_lat_v_IperF0/wav_v_lat_v_IperF0_std), 
								linscale=1, vmin=0, vmax=np.nanmax(wav_v_lat_v_IperF0/wav_v_lat_v_IperF0_std))
	im220 = a2[2,0].imshow(wav_v_lat_v_IperF0/wav_v_lat_v_IperF0_std, origin='lower', extent=extent, aspect='auto', norm=norm2, cmap=cmap)
	a2[2,0].set_title('IperF0/error')
	a2[2,0].set_xlabel('Wavelength (um)')
	a2[2,0].set_ylabel('Latitude (deg)')
	
	norm3 = mpl.colors.SymLogNorm(1E-3*np.nanmax(wav_v_lat_v_k/wav_v_lat_v_k_std), 
								linscale=1, vmin=0, vmax=np.nanmax(wav_v_lat_v_k/wav_v_lat_v_k_std))
	im221 = a2[2,1].imshow(wav_v_lat_v_k/wav_v_lat_v_k_std, origin='lower', extent=extent, aspect='auto', norm=norm3, cmap=cmap)
	a2[2,1].set_title('k/error')
	a2[2,1].set_xlabel('Wavelength (um)')
	a2[2,1].set_ylabel('Latitude (deg)')
	
	cb200 = f2.colorbar(im200, ax=a2[0,0], extend='both')
	cb200.set_label('IperF')
	cb201 = f2.colorbar(im201, ax=a2[0,1], extend='both')
	cb201.set_label('k')
	
	cb210 = f2.colorbar(im210, ax=a2[1,0], extend='both')
	cb210.set_label('IperF_err')
	cb211 = f2.colorbar(im211, ax=a2[1,1], extend='both')
	cb211.set_label('k_err')
	
	cb220 = f2.colorbar(im220, ax=a2[2,0], extend='both')
	cb220.set_label('IperF/err')
	cb221 = f2.colorbar(im221, ax=a2[2,1], extend='both')
	cb221.set_label('k/err')
	
	f2.suptitle('combined minnaert coefficients')
	
	f2.savefig(os.path.join(plot_dir, 'combined_wav_v_lat_v_minnaert_coefficients.png'), bbox_inches='tight')
	plt.close(f2)
	return()

# create animated plots of minnaert data and minnaert fit for each latitude slice
def plot_animated_minnaert_fit_each_lat(minnaert_input_files, minnaert_coefficient_files, plot_dir, overwrite=False):
	f2 = plt.figure()
	for m, (m_input_lat_file, m_coefficients_lat_file) in enumerate(zip(minnaert_input_files, minnaert_coefficient_files)):
		print(f'INFO: creating animated plot {m}/{len(minnaert_input_files)}')
		print(f'INFO: input file {os.path.basename(m_input_lat_file)}')
		print(f'INFO: coefficient file {os.path.basename(m_coefficients_lat_file)}')
		lat_max, lat_min = map(float,os.path.basename(m_input_lat_file).rsplit('.',1)[0].split('_')[-1:-4:-2])
		outfolder=plot_dir
		outfile = os.path.join(outfolder, f'combined_lat_{lat_min:+07.2f}_to_{lat_max:+07.2f}_IperF0_k_fit.mov')
		if os.path.exists(outfile) and (not overwrite):
			print(f'INFO: File {outfile} exists and we should not overwrite, skipping...')
			continue
		
		lcdata = np.load(m_coefficients_lat_file)
		IperF0s, ks, IperF0s_var, ks_var, wavs, log_IperF0s_var = (lcdata['IperF0s'], 
															 lcdata['ks'], 
															 lcdata['IperF0s_var'], 
															 lcdata['ks_var'], 
															 lcdata['wavs'], 
															 lcdata['log_IperF0s_var'])
		
		lidata = np.load(m_input_lat_file)
		IperF, u, u0, wavs = (lidata['IperF'], lidata['u'], lidata['u0'], lidata['wavs'])
		
		zen_grid = np.linspace(0,85,50)
		u_grid = np.linspace(np.min(u),np.max(u)) # np.cos(zen_grid*np.pi/180)
		u0_grid = u_grid[:]
		#log_u0u_grid = np.broadcast_to(np.log(u_grid*u0_grid), (ks.shape[0], u_grid.shape[0]))
		log_u0u_grid = np.log(u_grid*u0_grid)
		
		log_uIperF_fit = np.log(IperF0s[:,None]) + ks[:,None]*log_u0u_grid
		
		log_uIperF = np.log(u*IperF)
		log_u0u = np.log(u0*u)
		
		worst_log_uIperF_fits = np.zeros((ks.shape[0], u_grid.shape[0], 4))
		ks_lims = (ks+np.sqrt(ks_var), ks-np.sqrt(ks_var))
		log_IperF0s_lims = (np.log(IperF0s)+np.sqrt(log_IperF0s_var), np.log(IperF0s)-np.sqrt(log_IperF0s_var))
		_i = 0
		for _k in ks_lims:
			for _l in log_IperF0s_lims:
				worst_log_uIperF_fits[:,:,_i] = _l[:,None] + _k[:,None]*log_u0u_grid
				_i += 1
				
		wf_min = np.nanmin(worst_log_uIperF_fits, axis=-1)
		wf_max = np.nanmax(worst_log_uIperF_fits, axis=-1)
		
		f2.clear()
		a2 = f2.subplots(1,1,squeeze=False)
		def update(i):
			a2[0,0].clear()
			a2[0,0].plot(log_u0u[i,:], log_uIperF[i,:], '.')
			a2[0,0].plot(log_u0u_grid, log_uIperF_fit[i,:], '-', color='tab:pink', label='Minnaert fitted line')
			a2[0,0].fill_between(log_u0u_grid, wf_min[i,:], wf_max[i,:], color='tab:pink', alpha=0.5, label='Minnaert fitted line error region')
			
			f2.suptitle('combined observations', fontsize=6)
			a2[0,0].set_title(f'Minnaert limb darkening at wav {wavs[i]:05.3f} um\nlat {lat_min:+#04.1f} to {lat_max:+#04.1f} IperF0 {IperF0s[i]:05.2E} k {ks[i]:03.2f}')
			a2[0,0].set_xlabel('log[u0 u]')
			a2[0,0].set_ylabel('log[u (I/F)]')
			a2[0,0].legend()
			return
		
		ani = mpl.animation.FuncAnimation(f2, update, range(0,wavs.size), interval=50)
		
		os.makedirs(outfolder, exist_ok=True)
		print(f'INFO: Saving animation to {outfile}')
		ani.save(outfile, progress_callback=plotutils.progress)
	plt.close(f2)
	return()

# helper routine to group coefficients by latitude and wavelength
def minnaert_coefficients_to_lat_wav_format(minnaert_coefficient_files, lat_grid=np.linspace(-90,90,180), wav_plot_lims=(1.455, 2.455)):
	n_cmcf = len(minnaert_coefficient_files)
	
	wav_v_lat_v_IperF0 = None
	wav_v_lat_v_k = None
	wav_v_lat_coverage = None
	wav_v_lat_v_IperF0_std = None
	wav_v_lat_v_k_std = None
	wavelength_plot_lim_range = wav_plot_lims  # wavelength range to set the plot limits with
	
	for i, cmcf in enumerate(minnaert_coefficient_files):
		print(f'INFO: creating plots of {cmcf} {i}/{n_cmcf}')
		
		lat_min = float(cmcf.split('_')[-3])
		lat_max = float(cmcf.split('_')[-1].rsplit('.',1)[0])
		print(lat_min, lat_max)
		
		
		dl = np.load(cmcf)
		wavs, IperF0s, ks, log_IperF0s_var, ks_var, IperF0s_var, n_points, n_used_points = (dl['wavs'], dl['IperF0s'], dl['ks'], 
																	dl['log_IperF0s_var'], dl['ks_var'], dl['IperF0s_var'],
																	dl['n_points'], dl['n_used_points'])
		
		shape = (lat_grid.size, wavs.size)
		if wav_v_lat_coverage is None:
			wav_v_lat_coverage = np.zeros(shape)
		if wav_v_lat_v_IperF0 is None:
			wav_v_lat_v_IperF0 = np.zeros(shape)
		if wav_v_lat_v_k is None:
			wav_v_lat_v_k = np.zeros(shape)
		if wav_v_lat_v_IperF0_std is None:
			wav_v_lat_v_IperF0_std = np.zeros(shape)
		if wav_v_lat_v_k_std is None:
			wav_v_lat_v_k_std = np.zeros(shape)
								
		lat_idx = np.nonzero((lat_min < lat_grid) & (lat_grid < lat_max))
		wav_v_lat_v_IperF0[lat_idx,:] += IperF0s[None,:]
		wav_v_lat_v_k[lat_idx,:] += ks[None,:]
		wav_v_lat_coverage[lat_idx,:] += 1
		wav_v_lat_v_IperF0_std[lat_idx,:] += np.sqrt(IperF0s_var)[None,:]
		wav_v_lat_v_k_std[lat_idx,:] += np.sqrt(ks_var)[None,:]
		print(wav_v_lat_v_IperF0_std[lat_idx])
	
	covered = (wav_v_lat_coverage != 0)
	wav_v_lat_v_IperF0[covered] /= wav_v_lat_coverage[covered]
	wav_v_lat_v_k[covered] /= wav_v_lat_coverage[covered]
	wav_v_lat_v_IperF0_std[covered] /= wav_v_lat_coverage[covered]
	wav_v_lat_v_k_std[covered] /= wav_v_lat_coverage[covered]
	
	wav_v_lat_v_IperF0[~covered] = np.nan
	wav_v_lat_v_k[~covered] = np.nan
	wav_v_lat_v_IperF0_std[~covered] = np.nan
	wav_v_lat_v_k_std[~covered] = np.nan
		
	return(wav_v_lat_v_IperF0, wav_v_lat_v_k, wav_v_lat_v_IperF0_std, wav_v_lat_v_k_std)

########################### USER INTERFACE ROUTINES ###########################

def parse_args(argv):
	"""Parses command line arguments, see https://docs.python.org/3/library/argparse.html"""
	import argparse as ap
	"""
	# =====================
	# FORMATTER INFORMATION
	# ---------------------
	A formatter that inherits from multiple formatter classes has all the attributes of those formatters
	see https://docs.python.org/3/library/argparse.html#formatter-class for more information on what each
	of them do.
	Quick reference:
	ap.RawDescriptionHelpFormatter -> does not alter 'description' or 'epilog' text in any way
	ap.RawTextHelpFormatter -> Maintains whitespace in all help text, except multiple new lines are treated as one
	ap.ArgumentDefaultsHelpFormatter -> Adds a string at the end of argument help detailing the default parameter
	ap.MetavarTypeHelpFormatter -> Uses the type of the argument as the display name in help messages
	# =====================	
	"""
	class RawDefaultTypeFormatter(ap.RawDescriptionHelpFormatter, ap.ArgumentDefaultsHelpFormatter, ap.MetavarTypeHelpFormatter):
		pass
	class RawDefaultFormatter(ap.RawDescriptionHelpFormatter, ap.ArgumentDefaultsHelpFormatter):
		pass
	class TextDefaultTypeFormatter(ap.RawTextHelpFormatter, ap.ArgumentDefaultsHelpFormatter, ap.MetavarTypeHelpFormatter):
		pass
	class TextDefaultFormatter(ap.RawTextHelpFormatter, ap.ArgumentDefaultsHelpFormatter):
		pass

	#parser = ap.ArgumentParser(description=__doc__, formatter_class = ap.TextDefaultTypeFormatter, epilog='END OF USAGE')
	# ====================================
	# UNCOMMENT to enable block formatting
	# ------------------------------------
	parser = ap.ArgumentParser	(	description=ut.str_block_indent_raw(ut.str_rationalise_newline_for_wrap(__doc__), wrapsize=79),
									formatter_class = RawDefaultTypeFormatter,
									epilog=ut.str_block_indent_raw(ut.str_rationalise_newline_for_wrap('END OF USAGE'), wrapsize=79)
								)
	# ====================================

	parser.add_argument('minnaert.inputs', type=str, nargs='+', help='A list of minnaert input files to operate on')
	
	parser.add_argument('--save.dir', type=str, help='Directory to save results to.', 
					 default=os.path.expanduser('~/scratch/reduced_images/SINFO.combined/minnaert_clean'))
	
	plotutils.add_plot_arguments(parser)
	# TODO:
	#	* change plot.dir help message to 'Directory relative to "--save.dir" to save plots to'
	
	parsed_args = vars(parser.parse_args(argv))
	
	# process arguments 
	parsed_args['plots.dir'] = os.path.join(parsed_args['save.dir'], parsed_args['plots.dir'])
	
	return(parsed_args)


def main(argv):
	args = parse_args(argv)
	print(ut.str_wrap_in_tag(ut.str_dict(args), 'ARGUMENTS'))
	
	os.makedirs(args['save.dir'], exist_ok=True)
	os.makedirs(args['plots.dir'], exist_ok=True)
	
	combined_m_input_lat_files = combine_minnaert_inputs(args['minnaert.inputs'], args['save.dir'], overwrite=True)
	
	combined_m_coefficient_lat_files = combined_minnaert_coefficients(combined_m_input_lat_files, overwrite=True)
	
	plot_k_IperF0_wav_per_lat(combined_m_coefficient_lat_files, args['plots.dir'])
	
	plot_k_IperF0_wav_lat(combined_m_coefficient_lat_files, args['plots.dir'])
	
	#plot_animated_minnaert_fit_each_lat(combined_m_input_lat_files, combined_m_coefficient_lat_files, args['plots.dir'], overwrite=False)
	
	return
	
# setup inputs
if __name__=='__main__':
	# DEBUGGING
	if sys.argv[0] == '':
		plt.ioff()
		
		fits_dir = os.path.expanduser('~/scratch/reduced_images')
		m_input_lat_files = glob.glob(f'{fits_dir}/*/*/analysis/minnaert/*cleanMR2_200_minnaert_inputs_lat_*_to_*.npz')
		combined_dir = os.path.join(fits_dir, 'SINFO.combined', 'minnaert_cleanMR2_200')
		plot_dir = os.path.join(combined_dir, 'plots')
		
		sys.argv = ['', *m_input_lat_files, '--save.dir',  combined_dir, '--plots.dir', './plots']
		print(sys.argv)
	main(sys.argv[1:])
	
	
